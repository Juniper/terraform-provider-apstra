---
page_title: "apstra_datacenter_blueprint Resource - terraform-provider-apstra"
subcategory: "Reference Design: Datacenter"
description: |-
  This resource instantiates a Datacenter Blueprint from a template.
---

# apstra_datacenter_blueprint (Resource)

This resource instantiates a Datacenter Blueprint from a template.


## Example Usage

```terraform
# This example instantiates a blueprint from a template,
# allocates IPv4 and ASN resource pools to template roles
# and deploys the template.

# Instantiate a blueprint from a template
resource "apstra_datacenter_blueprint" "instantiation" {
  name        = "terraform commit example"
  template_id = "L2_Virtual_EVPN"
}

# ASN pools, IPv4 pools and switch devices will be allocated using looping
# resources. These three `local` maps are what we'll loop over.
locals {
  asn_pools = {
    spine_asns = ["Private-64512-65534"]
    leaf_asns  = ["Private-4200000000-4294967294"]
  }
  ipv4_pools = {
    spine_loopback_ips  = ["Private-10_0_0_0-8"]
    leaf_loopback_ips   = ["Private-10_0_0_0-8"]
    spine_leaf_link_ips = ["Private-10_0_0_0-8"]
  }
  switches = {
    spine2               = "Juniper_vQFX__AOS-7x10-Spine"
    spine1               = "Juniper_vQFX__AOS-7x10-Spine"
    l2_virtual_001_leaf1 = "Juniper_vQFX__AOS-7x10-Leaf"
    l2_virtual_002_leaf1 = "Juniper_vQFX__AOS-7x10-Leaf"
    l2_virtual_003_leaf1 = "Juniper_vQFX__AOS-7x10-Leaf"
    l2_virtual_004_leaf1 = "Juniper_vQFX__AOS-7x10-Leaf"
  }
}

# Assign interface maps to fabric roles to eliminate build errors so we
# can deploy
resource "apstra_datacenter_device_allocation" "interface_map_assignment" {
  for_each         = local.switches
  blueprint_id     = apstra_datacenter_blueprint.instantiation.id
  node_name        = each.key
  initial_interface_map_id = each.value
}

# Assign ASN pools to fabric roles to eliminate build errors so we
# can deploy
resource "apstra_datacenter_resource_pool_allocation" "asn" {
  for_each     = local.asn_pools
  blueprint_id = apstra_datacenter_blueprint.instantiation.id
  role         = each.key
  pool_ids     = each.value
}

# Assign IPv4 pools to fabric roles to eliminate build errors so we
# can deploy
resource "apstra_datacenter_resource_pool_allocation" "ipv4" {
  for_each     = local.ipv4_pools
  blueprint_id = apstra_datacenter_blueprint.instantiation.id
  role         = each.key
  pool_ids     = each.value
}

# The only required field for deployment is blueprint_id, but we're ensuring
# sensible run order and setting a custom commit message.
resource "apstra_blueprint_deployment" "deploy" {
  blueprint_id = apstra_datacenter_blueprint.instantiation.id

  #ensure that deployment doesn't run before build errors are resolved
  depends_on = [
    apstra_datacenter_device_allocation.interface_map_assignment,
    apstra_datacenter_resource_pool_allocation.asn,
    apstra_datacenter_resource_pool_allocation.ipv4,
  ]

  # Version is replaced using `text/template` method. Only predefined values
  # may be replaced with this syntax. USER is replaced using values from the
  # environment. Any environment variable may be specified this way.
  comment      = "Deployment by Terraform {{.TerraformVersion}}, Apstra provider {{.ProviderVersion}}, User $USER."
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) Blueprint name.
- `template_id` (String) ID of Rack Based Template used to instantiate the Blueprint.

### Optional

- `anti_affinity_mode` (String) Changing this value sets the anti_affinity_mode. The anti-affinity policy has three modes:Disabled (default) - ports selection is based on assigned interface maps and interface names (provided or auto-assigned). Port breakouts could terminate on the same physical ports.Enabled (loose) - controls interface names that were not defined by the user. Does not control or override user-defined cabling. (If you haven't explicitly assigned any interface names, loose and strict are effectively the same policy.)Enabled (strict) - completely controls port distribution and could override user-defined assignments. When you enable the strict policy, a statement appears at the top of the cabling map (Staged/Active > Physical > Links and Staged/Active > Physical > Topology Selection) stating that the anti-affinity policy is enabled.
- `anti_affinity_policy` (Attributes) When designing high availability (HA) systems, you want parallel links between two devices to terminate on different physical ports, thus avoiding transceiver failures from impacting both links on a device. Depending on the number of interfaces on a system, manually modifying these links could be time-consuming. With the anti-affinity policy you can apply certain constraints to the cabling map to control automatic port assignments. (see [below for nested schema](#nestedatt--anti_affinity_policy))
- `default_ip_links_to_generic_systems_mtu` (Number) Default L3 MTU for IP links to generic systems. A null or empty value implies AOS will not render explicit MTU value and system defaults will be used. Should be an even number between 1280 and 9216.
- `default_svi_l3_mtu` (Number) Default L3 MTU for SVI interfaces. Should be an even number in a range 1280 and 9216.Requires Apstra 4.2 or later.
- `esi_mac_msb` (Number) ESI MAC address most significant byte. Must be an even number between 0 and 254 inclusive.
- `evpn_type_5_routes` (String) Default disabled. When enabled all EVPN vteps in the fabric will redistribute ARP/IPV6 ND (when possible on NOS type) as EVPN type 5 /32 routes in the routing table. Currently, this option is only certified for Juniper JunOS. FRR (SONiC) does this implicitly and cannot be disabled. This setting will be ignored. On Arista and Cisco, no configuration is rendered and will result in a blueprint warning that it is not supported by AOS. This value is disabled by default, as it generates a very large number of routes in the BGP routing table and takes large amounts of TCAM allocation space. When these /32 & /128 routes are generated, it assists in direct unicast routing to host destinations on VNIs that are not stretched to the ingress vtep, and avoids a route lookup to a subnet (eg, /24) that may be hosted on many leafs. The directed host route prevents a double lookup to one of many vteps may hosts the /24 and instead routes the destination directly to the correct vtep.
- `fabric_addressing` (String) Addressing scheme for both superspine/spine and spine/leaf links. Only applicable to Apstra versions 4.1.1 and later. Must be one of: ipv4, ipv6, ipv4_ipv6
- `fabric_mtu` (Number) MTU of fabric links. Must be an even number between 1280 and 9216. Requires Apstra 4.2.0 or later.
- `ipv6_applications` (Boolean) Enables support for IPv6 virtual networks and IPv6 external connectivity points. This adds resource requirements and device configurations, including IPv6 loopback addresses on leafs, spines and superspines, IPv6 addresses for MLAG SVI subnets and IPv6 addresses for leaf L3 peer links. This option cannot be disabled without re-creating the Blueprint.
- `junos_evpn_max_nexthop_and_interface_number` (String) Changing this value will result in a disruptive restart of the PFE.Enables configuring the maximum number of nexthops and interface numbers reserved for use in EVPN-VXLAN overlay network on Junos leaf devices. Default is enabled.
- `junos_evpn_routing_instance_mode` (String) In releases before 4.2, Apstra used a single default switch instance as the configuration model for Junos. In Apstra 4.2, Apstra transitioned to using MAC-VRF for all new blueprints and normalized the configuration of Junos to Junos Evolved. This option allows you to transition Junos devices to the MAC-VRF configuration model for any blueprints deployed before the 4.2 release. All models use the VLAN-Aware service type.
- `junos_ex_overlay_ecmp` (String) Changing this value will result in a disruptive restart of the PFE on EX-series devicesEnables VXLAN Overlay ECMP on Junos EX-series devices
- `junos_graceful_restart` (String) Changing this value may result in a flap of all BGP sessions as the sessions are re-negotiatedEnables the Graceful Restart feature on Junos devices
- `max_evpn_routes_count` (Number) Maximum number of EVPN routes to accept on an EVPN switch. The default (None) will not render any maximum-route commands on BGP sessions, implying that only vendor defaults are used. An integer between 1-2**32-1 will set a maximum limit of routes in BGP config. The value 0 (zero) intends the device to never apply a limit to number of EVPN routes (effectively unlimited). Note: Device vendors typically shut down BGP sessions if maximums are exceeded on a session.
- `max_external_routes_count` (Number) Maximum number of routes to accept from external routers. The default (None) will not render any maximum-route commands on BGP sessions, implying that only vendor defaults are used.An integer between 1-2**32-1 will set a maximum limit of routes in BGP config. The value 0 (zero)intends the device to never apply a limit to number of EVPN routes (effectively unlimited). It is suggested this value is value is effectively unlimited on evpn blueprints, to permit the high number of /32 and /128 routes to be advertised and received between VRFs in the event an external router is providing a form of route leaking functionality.
- `max_fabric_routes_count` (Number) Maximum number of routes to accept between spine and leaf in the fabric, and spine-superspine. This includes the default VRF. Setting this option may be required in the event of leaking EVPN routes from a security zone into the default security zone (VRF) which could generate a large number of /32 and /128 routes. It is suggested that this value is effectively unlimited on all blueprints to ensure the network stability of spine-leaf bgp sessions and evpn underlay. Unlimited is also suggested for non-evpn blueprints considering the impact to traffic if spine-leaf sessions go offline. An integer between 1-2**32-1 will set a maximum limit of routes in BGP config. The value 0 (zero) intends the device to never apply a limit to number of fabric routes (effectively unlimited).
- `max_mlag_routes_count` (Number) Maximum number of routes to accept across MLAG peer switches. The default (None) will not render any maximum-route commands on BGP sessions, implying that only vendor defaults are used. An integer between 1-2**32-1 will set a maximum limit of routes in BGP config. The value 0 (zero) intends the device to never apply a limit to number of EVPN routes (effectively unlimited). Note: Device vendors typically shut down BGP sessions if maximums are exceeded on a session. For EVPN blueprints, this should be combined with max_evpn_routes to permit routes across the l3 peer link which may contain many /32 and /128 from EVPN type-2 routes that convert into BGP route advertisements.
- `optimize_routing_zone_footprint` (Boolean) When `true`: routing zones will not be rendered on leafs where it is not required,which results in less resource consumption. Routing zone will only be rendered for systems which have other structures configured on top of routing zone, such as virtual networks, protocol sessions, static routes, sub-interfaces, etc. Requires Apstra 4.2 or Later

### Read-Only

- `access_switch_count` (Number) The count of access switches in the topology.
- `build_errors_count` (Number) Number of build errors.
- `build_warnings_count` (Number) Number of build warnings.
- `external_router_count` (Number) The count of external routers attached to the topology.
- `generic_system_count` (Number) The count of generic systems in the topology.
- `has_uncommitted_changes` (Boolean) Indicates whether the staging blueprint has uncommitted changes.
- `id` (String) Blueprint ID assigned by Apstra.
- `leaf_switch_count` (Number) The count of leaf switches in the topology.
- `spine_count` (Number) The count of spine devices in the topology.
- `status` (String) Deployment status of the Blueprint
- `superspine_count` (Number) For 5-stage topologies, the count of superspine devices
- `version` (Number) Currently active blueprint version

<a id="nestedatt--anti_affinity_policy"></a>
### Nested Schema for `anti_affinity_policy`

Required:

- `max_links_count_per_port` (Number) Maximum total number of links connected to the interfaces of the specific port regardless of the system they are targeted to. It controls how many links can be connected to one port in one system. Example: Several transformations of one port. In this case, it controls how many transformations can be used in links.
- `max_links_count_per_slot` (Number) Maximum total number of links connected to ports/interfaces of the specified slot regardless of the systemthey are targeted to. It controls how many links can be connected to one slot of one system. Example: A line card slot in a chassis.
- `max_links_count_per_system_per_port` (Number) Restricts the number of interfaces on a port used to connect to a certain system. It controls how many links can be connected from one system to one port of another system. This is the one that you will most likely use, for port breakouts.
- `max_links_count_per_system_per_slot` (Number) Restricts the number of links to a certain system connected to the ports/interfaces in a specific slot. It controls how many links can be connected to one system to one slot of another system.



